{
    "typescript": [
        "interior(x, y, matrix): boolean {",
        "    if (x >= 0 && x < matrix.height && y >= 0 && y < matrix.width)",
        "        return true;",
        "    return false;",
        "}",
        "distManhattan(cellA, cellB) {",
        "    return Math.abs(cellA.x - cellB.x) + Math.abs(cellA.y - cellB.y);",
        "}",
        "run(input: AStarInput[]) {",
        "    var matrix = input[0];",
        "    var cost: number[][] = new Array(matrix.height), prev: any[][] = new Array(matrix.height);",
        "    for (var i = 0; i < matrix.height; i++) {",
        "        cost[i] = new Array(matrix.width);",
        "        cost[i].fill(matrix.height * matrix.width, 0, matrix.width);",
        "        prev[i] = new Array(matrix.width);",
        "    }",
        "    for (var wall of matrix.walls) {",
        "        cost[wall.x][wall.y] = -1;",
        "    }",
        "    var queue = new PriorityQueue({",
        "        comparator: function (a, b) {",
        "            return a.cost - b.cost;",
        "        }",
        "    });",
        "    queue.queue({ x: matrix.start.x, y: matrix.start.y, cost: 0 + this.distManhattan(matrix.start, matrix.stop) });",
        "    cost[matrix.start.x][matrix.start.y] = 0 + this.distManhattan(matrix.start, matrix.stop);",
        "    var dx = [-1, 0, 1, 0];",
        "    var dy = [0, 1, 0, -1];",
        "    while (queue.length > 0) {",
        "        var currentCell = queue.dequeue();",
        "        if (currentCell.cost == cost[currentCell.x][currentCell.y]) {",
        "            if (currentCell.x == matrix.stop.x && currentCell.y == matrix.stop.y)",
        "                break;",
        "            for (var i = 0; i < 4; i++) {",
        "                var newX = currentCell.x + dx[i], newY = currentCell.y + dy[i];",
        "                var newCost = currentCell.cost - this.distManhattan({ x: currentCell.x, y: currentCell.y }, matrix.stop) + 1 + this.distManhattan({ x: newX, y: newY }, matrix.stop);",
        "                if (this.interior(newX, newY, matrix) == true && cost[newX][newY] > newCost) {",
        "                    cost[newX][newY] = newCost;",
        "                    prev[newX][newY] = { x: currentCell.x, y: currentCell.y };",
        "                    queue.queue({ x: newX, y: newY, cost: newCost });",
        "                }",
        "            }",
        "        }",
        "    }",
        "}"
    ]    
}